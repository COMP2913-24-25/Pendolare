name: Deploy Message Service to Azure

on:
  pull_request:
    branches: 
      - main
      - dev
      - project/message-service
    paths:
      - 'Pendo.MessageService/**'
      - 'infrastructure/message-service.bicep'
  workflow_dispatch:

env:
  ACR_NAME: pendocontainerregistry
  MESSAGE_SERVICE_IMAGE_NAME: message-service
  RESOURCE_GROUP: dev
  CONTAINER_APP_NAME: message-service
  KONG_GATEWAY_NAME: kong-gateway
  CONTAINER_APP_ENV: pendo-env-dev

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    
    steps:
    - uses: actions/checkout@v2

    - name: Azure Login
      uses: azure/login@v1
      with:
        client-id: '0a6d7ce5-4951-4af8-932a-94714dd9e70b'
        tenant-id: '0adc3547-e686-4727-9a4c-0c5bb6699047'
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        enable-AzPSSession: true

    # Check if Kong Gateway exists before attempting to interact with it
    - name: Check Kong Gateway Existence
      id: check_kong
      run: |
        KONG_EXISTS=$(az containerapp show --name ${{ env.KONG_GATEWAY_NAME }} --resource-group ${{ env.RESOURCE_GROUP }} --query name -o tsv 2>/dev/null || echo "not_found")
        
        if [ "$KONG_EXISTS" == "not_found" ]; then
          echo "::set-output name=exists::false"
          echo "WARNING: Kong Gateway not found. Will deploy without Kong integration."
        else
          echo "::set-output name=exists::true"
          
          # Get Kong FQDN
          KONG_FQDN=$(az containerapp show --name ${{ env.KONG_GATEWAY_NAME }} --resource-group ${{ env.RESOURCE_GROUP }} --query properties.configuration.ingress.fqdn -o tsv)
          echo "KONG_GATEWAY_FQDN=$KONG_FQDN" >> $GITHUB_ENV
          echo "::set-output name=fqdn::$KONG_FQDN"
          
          echo "Kong Gateway found at: $KONG_FQDN"
        fi

    - name: Build and push image to ACR
      env:
        ACR_USERNAME: ${{ secrets.ACR_USERNAME }}
        ACR_PASSWORD: ${{ secrets.ACR_PASSWORD }}
      run: |
        docker login ${{ env.ACR_NAME }}.azurecr.io -u $ACR_USERNAME -p $ACR_PASSWORD
        cd Pendo.MessageService
        docker build . -t ${{ env.ACR_NAME }}.azurecr.io/${{ env.MESSAGE_SERVICE_IMAGE_NAME }}:${{ github.sha }}
        docker push ${{ env.ACR_NAME }}.azurecr.io/${{ env.MESSAGE_SERVICE_IMAGE_NAME }}:${{ github.sha }}
        docker tag ${{ env.ACR_NAME }}.azurecr.io/${{ env.MESSAGE_SERVICE_IMAGE_NAME }}:${{ github.sha }} ${{ env.ACR_NAME }}.azurecr.io/${{ env.MESSAGE_SERVICE_IMAGE_NAME }}:latest
        docker push ${{ env.ACR_NAME }}.azurecr.io/${{ env.MESSAGE_SERVICE_IMAGE_NAME }}:latest

    - name: Deploy Container App
      uses: azure/CLI@v1
      with:
        inlineScript: |
          az deployment group create \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --template-file infrastructure/message-service.bicep \
            --parameters \
              containerAppName=${{ env.CONTAINER_APP_NAME }} \
              containerAppEnvironmentName=${{ env.CONTAINER_APP_ENV }} \
              registryName=${{ env.ACR_NAME }} \
              registryUsername=${{ secrets.ACR_USERNAME }} \
              registryPassword=${{ secrets.ACR_PASSWORD }} \
              kongGatewayFqdn=${{ steps.check_kong.outputs.fqdn }}

    # Automated Network Setup
    - name: Setup Network Configuration
      if: steps.check_kong.outputs.exists == 'true'
      uses: azure/CLI@v1
      with:
        inlineScript: |
          # Get FQDNs for both services
          KONG_FQDN=$(az containerapp show --name ${{ env.KONG_GATEWAY_NAME }} --resource-group ${{ env.RESOURCE_GROUP }} --query properties.configuration.ingress.fqdn -o tsv)
          MESSAGE_FQDN=$(az containerapp show --name ${{ env.CONTAINER_APP_NAME }} --resource-group ${{ env.RESOURCE_GROUP }} --query properties.configuration.ingress.fqdn -o tsv)
          
          echo "Kong Gateway FQDN: $KONG_FQDN"
          echo "Message Service FQDN: $MESSAGE_FQDN"
          
          # Update environment variables for Message Service to know about Kong
          echo "Updating Message Service environment variables..."
          az containerapp update \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --set-env-vars "KONG_GATEWAY_URL=https://$KONG_FQDN"
          
          # Check if services are in the same environment
          KONG_ENV=$(az containerapp show --name ${{ env.KONG_GATEWAY_NAME }} --resource-group ${{ env.RESOURCE_GROUP }} --query properties.managedEnvironmentId -o tsv)
          MESSAGE_ENV=$(az containerapp show --name ${{ env.CONTAINER_APP_NAME }} --resource-group ${{ env.RESOURCE_GROUP }} --query properties.managedEnvironmentId -o tsv)
          
          if [ "$KONG_ENV" == "$MESSAGE_ENV" ]; then
            echo "Services are in the same Container App Environment. Internal networking is available."
          else
            echo "WARNING: Services are in different environments. Internal networking won't work correctly."
            echo "You may need to manually update the Container App Environment settings."
          fi

    # Configure Kong API Gateway
    - name: Configure Kong Gateway Routes
      if: steps.check_kong.outputs.exists == 'true'
      uses: azure/CLI@v1
      with:
        inlineScript: |
          MESSAGE_SERVICE_FQDN=$(az containerapp show --name ${{ env.CONTAINER_APP_NAME }} --resource-group ${{ env.RESOURCE_GROUP }} --query properties.configuration.ingress.fqdn -o tsv || echo "message-service")
          
          echo "Configuring Kong Gateway to route to Message Service at $MESSAGE_SERVICE_FQDN"
          
          # This is a safer way to handle the updating of Kong configuration using environment variables
          cat > kong-route-update.sh << 'EOF'
          #!/bin/bash
          # Access the service inside the Container App Environment using internal DNS name
          SERVICE_NAME="$1"  # message-service
          KONG_NAME="$2"     # kong-gateway
          
          # When inside the same Container App Environment, services can discover each other by name
          echo "Adding service: $SERVICE_NAME"
          
          # Create Kong Admin API call to create service - using internal Container App DNS
          cat > kong-service-creation.json << EOL
          {
            "name": "$SERVICE_NAME",
            "url": "http://$SERVICE_NAME:5006"
          }
          EOL
          
          # Create WebSocket route - FIXED: removed ws/wss protocols
          cat > kong-route-creation.json << EOL
          {
            "name": "${SERVICE_NAME}-ws-route",
            "paths": ["/ws"],
            "protocols": ["http", "https"],
            "headers": {
              "Upgrade": ["websocket"],
              "Connection": ["Upgrade"]
            },
            "strip_path": false
          }
          EOL
          
          echo "Kong configuration prepared - ready to apply via Kong API or declarative config"
          # Note: You would normally apply this using kubectl exec or direct API calls to the Kong Admin API
          EOF
          
          chmod +x kong-route-update.sh
          ./kong-route-update.sh ${{ env.CONTAINER_APP_NAME }} ${{ env.KONG_GATEWAY_NAME }}
          
          echo "Network configuration complete!"

    # Verify the deployment by checking the status
    - name: Verify deployment
      run: |
        echo "Waiting for Container App to be ready..."
        sleep 10  # Allow some time for the app to initialize
        
        # Get the status of the message service app
        APP_STATUS=$(az containerapp show --name ${{ env.CONTAINER_APP_NAME }} --resource-group ${{ env.RESOURCE_GROUP }} --query "properties.latestRevisionName" -o tsv)
        
        echo "Message Service status: $APP_STATUS"
        echo "Deployment complete!"
